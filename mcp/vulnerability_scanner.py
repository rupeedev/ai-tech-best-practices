#!/usr/bin/env python3
"""
Vulnerability & Secrets Scanner
Scans directories for exposed secrets, API keys, credentials, and sensitive information.
"""

import os
import re
import json
import argparse
from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict, Optional
from collections import defaultdict

# ANSI colors for terminal output
class Colors:
    RED = '\033[91m'
    YELLOW = '\033[93m'
    GREEN = '\033[92m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    END = '\033[0m'

@dataclass
class Finding:
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    category: str
    file_path: str
    line_number: int
    matched_text: str
    description: str
    pattern_name: str

# Secret detection patterns
SECRET_PATTERNS = {
    # API Keys & Tokens
    "AWS Access Key": {
        "pattern": r"AKIA[0-9A-Z]{16}",
        "severity": "CRITICAL",
        "description": "AWS Access Key ID exposed"
    },
    "AWS Secret Key": {
        "pattern": r"(?i)aws[_\-]?secret[_\-]?access[_\-]?key['\"]?\s*[:=]\s*['\"]?([A-Za-z0-9/+=]{40})",
        "severity": "CRITICAL",
        "description": "AWS Secret Access Key exposed"
    },
    "OpenAI API Key": {
        "pattern": r"sk-[A-Za-z0-9]{48,}",
        "severity": "CRITICAL",
        "description": "OpenAI API key exposed"
    },
    "Anthropic API Key": {
        "pattern": r"sk-ant-[A-Za-z0-9\-]{80,}",
        "severity": "CRITICAL",
        "description": "Anthropic API key exposed"
    },
    "GitHub Token": {
        "pattern": r"gh[pousr]_[A-Za-z0-9]{36,}",
        "severity": "CRITICAL",
        "description": "GitHub personal access token exposed"
    },
    "GitHub OAuth": {
        "pattern": r"gho_[A-Za-z0-9]{36}",
        "severity": "CRITICAL",
        "description": "GitHub OAuth token exposed"
    },
    "Slack Token": {
        "pattern": r"xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*",
        "severity": "CRITICAL",
        "description": "Slack token exposed"
    },
    "Slack Webhook": {
        "pattern": r"https://hooks\.slack\.com/services/T[A-Z0-9]+/B[A-Z0-9]+/[A-Za-z0-9]+",
        "severity": "HIGH",
        "description": "Slack webhook URL exposed"
    },
    "Stripe API Key": {
        "pattern": r"sk_live_[0-9a-zA-Z]{24,}",
        "severity": "CRITICAL",
        "description": "Stripe live API key exposed"
    },
    "Stripe Test Key": {
        "pattern": r"sk_test_[0-9a-zA-Z]{24,}",
        "severity": "MEDIUM",
        "description": "Stripe test API key exposed"
    },
    "Google API Key": {
        "pattern": r"AIza[0-9A-Za-z\-_]{35}",
        "severity": "HIGH",
        "description": "Google API key exposed"
    },
    "Firebase Key": {
        "pattern": r"AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}",
        "severity": "HIGH",
        "description": "Firebase Cloud Messaging key exposed"
    },
    "Twilio API Key": {
        "pattern": r"SK[0-9a-fA-F]{32}",
        "severity": "HIGH",
        "description": "Twilio API key exposed"
    },
    "SendGrid API Key": {
        "pattern": r"SG\.[A-Za-z0-9\-_]{22}\.[A-Za-z0-9\-_]{43}",
        "severity": "HIGH",
        "description": "SendGrid API key exposed"
    },
    "Mailchimp API Key": {
        "pattern": r"[0-9a-f]{32}-us[0-9]{1,2}",
        "severity": "HIGH",
        "description": "Mailchimp API key exposed"
    },
    "NPM Token": {
        "pattern": r"npm_[A-Za-z0-9]{36}",
        "severity": "HIGH",
        "description": "NPM access token exposed"
    },
    "PyPI Token": {
        "pattern": r"pypi-[A-Za-z0-9]{60,}",
        "severity": "HIGH",
        "description": "PyPI API token exposed"
    },
    # Removed: UUID pattern causes too many false positives (Notion IDs, etc.)
    "MindsDB PAT Token": {
        "pattern": r"pat_[A-Za-z0-9]{35,45}",
        "severity": "CRITICAL",
        "description": "MindsDB PAT token exposed"
    },
    "Generic Bearer Token": {
        "pattern": r"(?i)bearer\s+[A-Za-z0-9\-_\.]{20,}",
        "severity": "HIGH",
        "description": "Bearer token exposed"
    },

    # Passwords & Credentials
    "Password in Config": {
        "pattern": r"(?i)(password|passwd|pwd|pass)['\"]?\s*[:=]\s*['\"]([^'\"]{8,})['\"]",
        "severity": "CRITICAL",
        "description": "Password exposed in configuration"
    },
    "Password in URL": {
        "pattern": r"://[^:]+:([^@]{3,})@[^/]+",
        "severity": "CRITICAL",
        "description": "Password exposed in connection string"
    },
    "Database Connection String": {
        "pattern": r"(?i)(postgres|mysql|mongodb|redis|amqp)://[^:]+:[^@]+@[^\s]+",
        "severity": "CRITICAL",
        "description": "Database connection string with credentials"
    },
    "Secret Assignment": {
        "pattern": r"(?i)(secret|api_key|apikey|api-key|auth_token|access_token)['\"]?\s*[:=]\s*['\"]([A-Za-z0-9\-_\.]{16,})['\"]",
        "severity": "HIGH",
        "description": "Secret or API key assignment detected"
    },

    # Private Keys
    "RSA Private Key": {
        "pattern": r"-----BEGIN RSA PRIVATE KEY-----",
        "severity": "CRITICAL",
        "description": "RSA private key exposed"
    },
    "OpenSSH Private Key": {
        "pattern": r"-----BEGIN OPENSSH PRIVATE KEY-----",
        "severity": "CRITICAL",
        "description": "OpenSSH private key exposed"
    },
    "PGP Private Key": {
        "pattern": r"-----BEGIN PGP PRIVATE KEY BLOCK-----",
        "severity": "CRITICAL",
        "description": "PGP private key exposed"
    },
    "EC Private Key": {
        "pattern": r"-----BEGIN EC PRIVATE KEY-----",
        "severity": "CRITICAL",
        "description": "EC private key exposed"
    },
    "Generic Private Key": {
        "pattern": r"-----BEGIN (?:.*? )?PRIVATE KEY-----",
        "severity": "CRITICAL",
        "description": "Private key exposed"
    },

    # Cloud & Infrastructure
    "GCP Project ID": {
        "pattern": r"(?i)project[_\-]?id['\"]?\s*[:=]\s*['\"]([a-z][a-z0-9\-]{4,28}[a-z0-9])['\"]",
        "severity": "MEDIUM",
        "description": "GCP Project ID exposed"
    },
    "Azure Connection String": {
        "pattern": r"DefaultEndpointsProtocol=https;AccountName=[^;]+;AccountKey=[^;]+",
        "severity": "CRITICAL",
        "description": "Azure Storage connection string exposed"
    },
    "Azure SAS Token": {
        "pattern": r"sv=\d{4}-\d{2}-\d{2}&s[a-z]=.*&sig=[A-Za-z0-9%]+",
        "severity": "HIGH",
        "description": "Azure SAS token exposed"
    },

    # Personal Information
    "Email Address": {
        "pattern": r"[a-zA-Z0-9._%+-]+@(?!example\.com|test\.com|yourcompany\.com|acme\.com)[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
        "severity": "LOW",
        "description": "Email address found (verify if personal)"
    },
    "IP Address": {
        "pattern": r"(?<![\d.])((?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?![\d.])",
        "severity": "LOW",
        "description": "IP address found (verify if internal)"
    },

    # JWT & Session Tokens
    "JWT Token": {
        "pattern": r"eyJ[A-Za-z0-9\-_]+\.eyJ[A-Za-z0-9\-_]+\.[A-Za-z0-9\-_]+",
        "severity": "HIGH",
        "description": "JWT token exposed"
    },

    # Webhook & Callback URLs
    "Discord Webhook": {
        "pattern": r"https://discord\.com/api/webhooks/[0-9]+/[A-Za-z0-9\-_]+",
        "severity": "HIGH",
        "description": "Discord webhook URL exposed"
    },
    "Telegram Bot Token": {
        "pattern": r"[0-9]+:AA[A-Za-z0-9\-_]{33}",
        "severity": "HIGH",
        "description": "Telegram bot token exposed"
    },

    # Hex-encoded secrets (like Obsidian API keys)
    "Long Hex String": {
        "pattern": r"(?i)(api[_\-]?key|token|secret)['\"]?\s*[:=]\s*['\"]?([a-f0-9]{64})['\"]?",
        "severity": "HIGH",
        "description": "Long hex string (potential API key) exposed"
    },
    "Standalone Hex Key": {
        "pattern": r"(?<![a-f0-9])[a-f0-9]{64}(?![a-f0-9])",
        "severity": "MEDIUM",
        "description": "64-char hex string found (potential secret)"
    },
}

# Files and directories to skip
SKIP_DIRS = {
    '.git', '.venv', 'venv', 'node_modules', '__pycache__',
    '.idea', '.vscode', 'dist', 'build', '.next', '.cache',
    'coverage', '.pytest_cache', '.mypy_cache', 'egg-info'
}

SKIP_FILES = {
    '.DS_Store', 'Thumbs.db', 'package-lock.json', 'yarn.lock',
    'pnpm-lock.yaml', 'poetry.lock', 'Gemfile.lock',
    'vulnerability_scanner.py'  # Skip self to avoid pattern false positives
}

# Binary and non-text extensions to skip
BINARY_EXTENSIONS = {
    '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.webp',
    '.mp3', '.mp4', '.wav', '.avi', '.mov', '.webm',
    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
    '.zip', '.tar', '.gz', '.rar', '.7z',
    '.exe', '.dll', '.so', '.dylib', '.bin',
    '.woff', '.woff2', '.ttf', '.eot', '.otf',
    '.pyc', '.pyo', '.class', '.o', '.a'
}

# False positive patterns to ignore
FALSE_POSITIVE_PATTERNS = [
    r"YOUR_[A-Z_]+_HERE",
    r"<[A-Z_]+>",
    r"\$\{[A-Z_]+\}",
    r"EXAMPLE[_\-]",
    r"example\.com",
    r"test\.example",
    r"placeholder",
    r"dummy",
    r"REPLACE_ME",
    r"xxx+",
    r"000+",
    # Medium/social URLs with @ usernames
    r"medium\.com/@",
    r"twitter\.com/@",
    r"github\.com/",
    # Localhost IPs are safe
    r"127\.0\.0\.1",
    r"localhost",
    # Regex pattern strings (in scanner itself or docs)
    r"\\[/@:\[\]{}()]",
    r"\[A-Za-z",
    r"\[0-9",
    r"r\"",
    r"r'",
    # Default/example credentials in documentation
    r"admin@nocobase\.com",
    r"admin@example",
    # Image file references with @ in filename
    r"\.jpeg\)?",
    r"\.png\)?",
    r"@2x\.",
    # Markdown link patterns
    r"\]\(https:",
    r"\]\(http:",
    # Documentation URL patterns
    r"://miro\.medium\.com",
    r"://policy\.medium\.com",
    # Common documentation placeholders for passwords
    r"your_password",
    r"your-password",
    r":password@",  # Generic password placeholder in URLs
    r"username:password@hostname",
    r"user:pass@",
    r"user:password@",
    r"YOUR_[A-Z_]+",
    r"_FROM_STEP_",
    # Documentation connection string examples
    r"@hostname:port",
    r"@hostname:5432",
    r"@host:5432",
    # Generic documentation password examples
    r'"password": "password"',
    r'"password":"password"',
    r"password.*password",  # password field with value "password"
    # URLs followed by "Log in" text (documentation)
    r"\.com\s+\d+\.\s+Log in",
]


class VulnerabilityScanner:
    def __init__(self, root_path: str, verbose: bool = False):
        self.root_path = Path(root_path).resolve()
        self.verbose = verbose
        self.findings: List[Finding] = []
        self.stats = defaultdict(int)

    def should_skip_file(self, file_path: Path) -> bool:
        """Check if file should be skipped."""
        if file_path.name in SKIP_FILES:
            return True
        if file_path.suffix.lower() in BINARY_EXTENSIONS:
            return True
        return False

    def should_skip_dir(self, dir_path: Path) -> bool:
        """Check if directory should be skipped."""
        return dir_path.name in SKIP_DIRS

    def is_false_positive(self, matched_text: str) -> bool:
        """Check if match is a known false positive."""
        for fp_pattern in FALSE_POSITIVE_PATTERNS:
            if re.search(fp_pattern, matched_text, re.IGNORECASE):
                return True
        return False

    def scan_file(self, file_path: Path) -> List[Finding]:
        """Scan a single file for secrets."""
        findings = []

        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
        except Exception as e:
            if self.verbose:
                print(f"{Colors.YELLOW}Warning: Could not read {file_path}: {e}{Colors.END}")
            return findings

        for pattern_name, config in SECRET_PATTERNS.items():
            pattern = config["pattern"]
            severity = config["severity"]
            description = config["description"]

            try:
                for match in re.finditer(pattern, content, re.MULTILINE):
                    matched_text = match.group(0)

                    # Skip false positives
                    if self.is_false_positive(matched_text):
                        continue

                    # Find line number
                    start_pos = match.start()
                    line_number = content[:start_pos].count('\n') + 1

                    # Truncate long matches for display
                    display_text = matched_text
                    if len(display_text) > 80:
                        display_text = display_text[:40] + "..." + display_text[-20:]

                    finding = Finding(
                        severity=severity,
                        category=pattern_name,
                        file_path=str(file_path.relative_to(self.root_path)),
                        line_number=line_number,
                        matched_text=display_text,
                        description=description,
                        pattern_name=pattern_name
                    )
                    findings.append(finding)
                    self.stats[severity] += 1

            except re.error as e:
                if self.verbose:
                    print(f"{Colors.YELLOW}Regex error for {pattern_name}: {e}{Colors.END}")

        return findings

    def scan(self) -> List[Finding]:
        """Scan all files in the root path."""
        print(f"\n{Colors.BOLD}Scanning: {self.root_path}{Colors.END}\n")

        files_scanned = 0

        for root, dirs, files in os.walk(self.root_path):
            # Filter out directories to skip
            dirs[:] = [d for d in dirs if not self.should_skip_dir(Path(root) / d)]

            for filename in files:
                file_path = Path(root) / filename

                if self.should_skip_file(file_path):
                    continue

                if self.verbose:
                    print(f"Scanning: {file_path.relative_to(self.root_path)}")

                file_findings = self.scan_file(file_path)
                self.findings.extend(file_findings)
                files_scanned += 1

        self.stats['files_scanned'] = files_scanned
        return self.findings

    def print_report(self):
        """Print a formatted report of findings."""
        print(f"\n{'='*80}")
        print(f"{Colors.BOLD}VULNERABILITY SCAN REPORT{Colors.END}")
        print(f"{'='*80}\n")

        print(f"Root Path: {self.root_path}")
        print(f"Files Scanned: {self.stats['files_scanned']}")
        print(f"\n{'-'*80}\n")

        # Summary by severity
        severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
        severity_colors = {
            'CRITICAL': Colors.RED,
            'HIGH': Colors.YELLOW,
            'MEDIUM': Colors.CYAN,
            'LOW': Colors.BLUE
        }

        print(f"{Colors.BOLD}SUMMARY{Colors.END}\n")
        total = 0
        for severity in severity_order:
            count = self.stats.get(severity, 0)
            total += count
            color = severity_colors[severity]
            print(f"  {color}{severity}: {count}{Colors.END}")
        print(f"\n  TOTAL FINDINGS: {total}")

        if not self.findings:
            print(f"\n{Colors.GREEN}No secrets or vulnerabilities detected!{Colors.END}")
            print(f"{'='*80}\n")
            return

        print(f"\n{'-'*80}\n")
        print(f"{Colors.BOLD}DETAILED FINDINGS{Colors.END}\n")

        # Group by severity
        by_severity = defaultdict(list)
        for finding in self.findings:
            by_severity[finding.severity].append(finding)

        for severity in severity_order:
            findings = by_severity.get(severity, [])
            if not findings:
                continue

            color = severity_colors[severity]
            print(f"\n{color}{Colors.BOLD}[{severity}] {len(findings)} finding(s){Colors.END}\n")

            for i, finding in enumerate(findings, 1):
                print(f"  {i}. {Colors.BOLD}{finding.category}{Colors.END}")
                print(f"     File: {finding.file_path}:{finding.line_number}")
                print(f"     Description: {finding.description}")
                print(f"     Match: {Colors.RED}{finding.matched_text}{Colors.END}")
                print()

        print(f"{'='*80}")
        print(f"{Colors.BOLD}RECOMMENDED ACTIONS{Colors.END}")
        print(f"{'='*80}\n")

        if self.stats.get('CRITICAL', 0) > 0:
            print(f"{Colors.RED}1. CRITICAL: Immediately rotate all exposed credentials{Colors.END}")
            print("   - Change passwords and regenerate API keys")
            print("   - Check access logs for unauthorized usage")
            print()

        if self.stats.get('HIGH', 0) > 0 or self.stats.get('CRITICAL', 0) > 0:
            print("2. Remove secrets from code:")
            print("   - Replace with environment variables")
            print("   - Use placeholders like YOUR_API_KEY_HERE")
            print("   - Add sensitive files to .gitignore")
            print()

        print("3. Clean git history if secrets were committed:")
        print("   - Use BFG Repo-Cleaner or git filter-branch")
        print("   - Force push cleaned history")
        print()

        print("4. Prevent future exposure:")
        print("   - Add pre-commit hooks (detect-secrets, git-secrets)")
        print("   - Enable GitHub secret scanning")
        print("   - Use .env files for local development")

        print(f"\n{'='*80}\n")

    def export_json(self, output_path: str):
        """Export findings to JSON file."""
        data = {
            "root_path": str(self.root_path),
            "stats": dict(self.stats),
            "findings": [
                {
                    "severity": f.severity,
                    "category": f.category,
                    "file_path": f.file_path,
                    "line_number": f.line_number,
                    "matched_text": f.matched_text,
                    "description": f.description
                }
                for f in self.findings
            ]
        }

        with open(output_path, 'w') as f:
            json.dump(data, f, indent=2)

        print(f"Report exported to: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Scan directories for exposed secrets, API keys, and sensitive information"
    )
    parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to scan (default: current directory)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Show verbose output"
    )
    parser.add_argument(
        "-o", "--output",
        help="Export findings to JSON file"
    )
    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )

    args = parser.parse_args()

    # Disable colors if requested
    if args.no_color:
        for attr in dir(Colors):
            if not attr.startswith('_'):
                setattr(Colors, attr, '')

    scanner = VulnerabilityScanner(args.path, verbose=args.verbose)
    scanner.scan()
    scanner.print_report()

    if args.output:
        scanner.export_json(args.output)

    # Exit with error code if critical/high findings
    if scanner.stats.get('CRITICAL', 0) > 0:
        exit(2)
    elif scanner.stats.get('HIGH', 0) > 0:
        exit(1)
    exit(0)


if __name__ == "__main__":
    main()
